# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Unity 6000.3.2f1 (Unity 6) project configured with Universal Render Pipeline (URP) and the new Input System.

## Key Packages

- **Universal Render Pipeline (URP)**: 17.3.0 - Modern rendering pipeline
- **Input System**: 1.17.0 - New input system (not the legacy Input Manager)
- **AI Navigation**: 2.0.9 - NavMesh components
- **Visual Scripting**: 1.9.9 - Node-based scripting
- **Timeline**: 1.8.9 - Cinematic and animation sequencing
- **Test Framework**: 1.6.0 - Unity's testing framework

## Project Structure

```
Assets/
├── Scenes/              # Unity scenes
├── Settings/            # Project-specific settings
├── TutorialInfo/        # Template tutorial assets
└── InputSystem_Actions.inputactions  # Input Action asset
```

## Unity Editor Workflow

Unity projects are primarily developed through the Unity Editor, not through command-line builds. The `.csproj` and `.sln` files are auto-generated by Unity and should not be manually edited.

### Opening the Project
1. Open Unity Hub
2. Add this project folder
3. Open with Unity Editor 6000.3.2f1 or compatible version

### Creating Scripts
New C# scripts should be created through:
- Unity Editor: Right-click in Project window → Create → C# Script
- This ensures proper MonoBehaviour template and meta files

### Testing in Play Mode
- Use Unity Editor's Play button to test
- Scripts execute in the context of scenes and GameObjects

## Input System

This project uses the **new Input System**, not the legacy Input Manager.

- Input actions are defined in `Assets/InputSystem_Actions.inputactions`
- Access input through Input Action references, not `Input.GetKey()`
- Player Input component should be used on GameObjects

## Architecture Notes

### MonoBehaviour Lifecycle
Unity scripts inherit from MonoBehaviour and use Unity's lifecycle methods:
- `Awake()` - Called when script instance is loaded
- `Start()` - Called before first frame update
- `Update()` - Called every frame
- `FixedUpdate()` - Called at fixed time intervals (physics)
- `OnDestroy()` - Called when object is destroyed

### Scene-Based Architecture
- Logic is organized into scenes (`.unity` files)
- Scripts attach to GameObjects in the Hierarchy
- Communication between objects via references, events, or singleton patterns

### SerializeField Pattern
Unity serializes public fields and `[SerializeField]` private fields:
```csharp
[SerializeField] private float speed = 5f;  // Visible in Inspector
private float health = 100f;                 // Not visible in Inspector
```

## URP Rendering

This project uses Universal Render Pipeline:
- URP Asset configures rendering quality and features
- Custom shaders should use Shader Graph or URP shader templates
- Post-processing effects use Volume components
- URP-specific lighting and shadow settings apply

## Editor Scripts

Scripts in `Editor/` folders run in the Unity Editor, not in builds:
- Used for custom Inspector windows, menu items, asset processors
- Cannot reference `UnityEngine.MonoBehaviour` in built players
- Use `UnityEditor` namespace

## Testing

Unity Test Framework supports:
- **Edit Mode tests**: Test editor scripts and logic without Play Mode
- **Play Mode tests**: Test runtime behavior in simulated Play Mode
- Run tests via Unity Editor: Window → General → Test Runner

### Running Tests
Tests must be run through Unity Editor's Test Runner window, not command line in a standard workflow.

## Platform Considerations

- Unity builds to multiple platforms (Windows, Mac, Linux, iOS, Android, WebGL, consoles)
- Platform-specific code uses `#if UNITY_STANDALONE` preprocessor directives
- Input System automatically handles platform-specific input devices

## Common Patterns

### Singletons
```csharp
public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

### Coroutines
Unity's way of handling async behavior over time:
```csharp
IEnumerator DelayedAction()
{
    yield return new WaitForSeconds(2f);
    // Execute after 2 seconds
}

// Start with:
StartCoroutine(DelayedAction());
```

### ScriptableObjects
Data containers that persist as assets:
```csharp
[CreateAssetMenu(menuName = "Game/Data")]
public class GameData : ScriptableObject
{
    public int maxHealth;
    public float speed;
}
```
