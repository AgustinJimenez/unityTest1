# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Unity 6000.3.2f1 (Unity 6) project configured with Universal Render Pipeline (URP) and the new Input System.

## Key Packages

- **Universal Render Pipeline (URP)**: 17.3.0 - Modern rendering pipeline
- **Input System**: 1.17.0 - New input system (not the legacy Input Manager)
- **Animation Rigging**: 1.3.1 - Procedural animation with IK constraints
- **AI Navigation**: 2.0.9 - NavMesh components
- **Visual Scripting**: 1.9.9 - Node-based scripting
- **Timeline**: 1.8.9 - Cinematic and animation sequencing
- **Test Framework**: 1.6.0 - Unity's testing framework

## Project Structure

```
Assets/
├── Scenes/              # Unity scenes
├── Scripts/             # Game scripts and components
│   └── Editor/          # Editor tools and automation
├── Settings/            # Project-specific settings
├── TutorialInfo/        # Template tutorial assets
└── InputSystem_Actions.inputactions  # Input Action asset
```

## Development Workflow with Claude Code

### Iterative Development Cycle

When working with Claude Code on this Unity project, follow this workflow:

1. **Claude Code Updates Scripts**: Claude modifies C# files in `Assets/Scripts/`
2. **Unity Auto-Compiles**: Unity Editor detects file changes and recompiles automatically
   - Watch the bottom-right corner for the spinning icon (compiling)
   - Wait until it says "Ready" or the spinner disappears
   - **There is no command to force compilation** - Unity handles this internally
3. **User Tests in Unity Editor**: Press Play to test changes
4. **Provide Feedback**: Report what works/doesn't work
5. **Iterate**: Repeat steps 1-4 until feature is complete

### Audio Notifications (Task Completion)

Claude Code can play audio notifications when tasks are completed, so you know when long-running operations finish.

**Available Scripts:**
- `speak.ps1` - PowerShell script for text-to-speech using Windows built-in SAPI
- `speak.bat` - Batch wrapper for easy calling

**Usage:**
```bash
# Direct PowerShell call
powershell -ExecutionPolicy Bypass -File "E:\repo\unity\My project\speak.ps1" "Task completed successfully"

# Or using the inline command
powershell -c "Add-Type -AssemblyName System.Speech; (New-Object System.Speech.Synthesis.SpeechSynthesizer).Speak('Task completed')"
```

**When Claude uses this:**
- After git operations (commit, push)
- After long-running compilation or builds
- When explicitly requested by user
- When complex multi-step tasks finish

**Benefits:**
- No need to watch the terminal constantly
- Audible confirmation when Claude finishes work
- Can work on other things while Claude executes tasks

**Note:** Uses Windows built-in speech synthesis - no external dependencies required.

### Automated Setup Tools

This project includes Editor tools for quick setup:
- **Tools → Third Person → Auto Setup Scene**: Creates player, camera, and ground automatically
- **Tools → Third Person → Remove Setup**: Cleans up the scene setup
- These tools handle GameObject creation, component configuration, and linking

### Real-Time Value Tuning

For faster iteration when adjusting parameters:
1. Enter **Play Mode** in Unity Editor
2. Select the GameObject (e.g., Main Camera, Player)
3. Modify serialized fields directly in the Inspector
4. See changes **immediately** without stopping/restarting
5. Once satisfied, note the values and have Claude update the script defaults

**Note**: Changes made during Play Mode are lost when exiting Play Mode, so always have Claude update the script with final values.

### Script Compilation Limitations

- Unity Editor must be running for compilation to occur
- Compilation happens automatically when Unity detects file changes
- No external command-line tool can trigger Unity's internal compiler
- Asset refreshing (Assets → Refresh or Ctrl+R) can help if changes aren't detected

## Unity Editor Workflow

Unity projects are primarily developed through the Unity Editor, not through command-line builds. The `.csproj` and `.sln` files are auto-generated by Unity and should not be manually edited.

### Opening the Project
1. Open Unity Hub
2. Add this project folder
3. Open with Unity Editor 6000.3.2f1 or compatible version

### Creating Scripts
New C# scripts should be created through:
- Unity Editor: Right-click in Project window → Create → C# Script
- This ensures proper MonoBehaviour template and meta files

### Testing in Play Mode
- Use Unity Editor's Play button to test
- Scripts execute in the context of scenes and GameObjects

## Input System

This project uses the **new Input System**, not the legacy Input Manager.

- Input actions are defined in `Assets/InputSystem_Actions.inputactions`
- Access input through Input Action references, not `Input.GetKey()`
- Player Input component should be used on GameObjects

## Architecture Notes

### MonoBehaviour Lifecycle
Unity scripts inherit from MonoBehaviour and use Unity's lifecycle methods:
- `Awake()` - Called when script instance is loaded
- `Start()` - Called before first frame update
- `Update()` - Called every frame
- `FixedUpdate()` - Called at fixed time intervals (physics)
- `OnDestroy()` - Called when object is destroyed

### Scene-Based Architecture
- Logic is organized into scenes (`.unity` files)
- Scripts attach to GameObjects in the Hierarchy
- Communication between objects via references, events, or singleton patterns

### SerializeField Pattern
Unity serializes public fields and `[SerializeField]` private fields:
```csharp
[SerializeField] private float speed = 5f;  // Visible in Inspector
private float health = 100f;                 // Not visible in Inspector
```

## URP Rendering

This project uses Universal Render Pipeline:
- URP Asset configures rendering quality and features
- Custom shaders should use Shader Graph or URP shader templates
- Post-processing effects use Volume components
- URP-specific lighting and shadow settings apply

## Importing Mixamo Characters with Textures

### Common Issue: Dark or Missing Textures

When importing Mixamo characters (especially DAE format) into Unity URP, textures often appear dark or missing. This was resolved through the following understanding:

**Root Cause:**
- Mixamo characters use **multiple texture sets** (e.g., Ch31_1001 for body, Ch31_1002 for hair)
- All materials share the same prefix (e.g., "Ch31"), so naive texture searching finds ALL textures for ALL materials
- If you assign textures without filtering, the LAST texture overwrites all previous ones
- This causes wrong textures to be applied (e.g., dark hair texture on body material)

**Texture Naming Convention (Mixamo):**
- `Ch31_1001_Diffuse.png` - Body/skin texture (usually brighter)
- `Ch31_1002_Diffuse.png` - Hair texture (usually darker)
- `Ch31_1001_Normal.png` - Body normal map
- `Ch31_1001_Specular.png` - Body specular map
- Pattern: `{CharacterID}_{TextureSet}_{TextureType}.png`

**Solution:**
Match textures to materials intelligently based on material names:
```csharp
// Determine which texture set to use based on material name
string preferredTextureNumber = "";
if (materialName.ToLower().Contains("hair"))
{
    preferredTextureNumber = "1002"; // Hair textures
}
else if (materialName.ToLower().Contains("body"))
{
    preferredTextureNumber = "1001"; // Body textures
}

// Only assign textures that match the preferred set
bool isPreferredTexture = string.IsNullOrEmpty(preferredTextureNumber)
    || textureName.Contains(preferredTextureNumber);
```

**Key Points:**
1. **DAE files are 100x too large** - Apply `transform.localScale = Vector3.one * 0.01f` for DAE imports
2. **Materials use Specular workflow** - Set `material.SetFloat("_WorkflowMode", 1f)` for URP/Lit shader
3. **Enable Specular keyword** - Call `material.EnableKeyword("_SPECULAR_SETUP")` to activate Specular rendering
4. **One diffuse per material** - Only assign the FIRST matching diffuse texture to prevent overwriting
5. **Normal maps must be configured** - Set texture import type to `TextureImporterType.NormalMap`

**Lighting Requirements:**
- Set ambient lighting: `RenderSettings.ambientMode = AmbientMode.Flat` with bright color
- Increase directional light intensity to 2-3 for better visibility
- Mixamo characters can appear dark without proper ambient lighting

**Eyelash Rendering Fix:**
Mixamo eyelashes often appear as thick black bars in Unity instead of subtle, natural lashes. This is because:
- Eyelashes use the hair material by default (too dark and opaque)
- They need alpha clipping and two-sided rendering to look natural

Solution - create a dedicated eyelash material:
```csharp
Material eyelashMaterial = new Material(Shader.Find("Universal Render Pipeline/Lit"));
eyelashMaterial.SetFloat("_AlphaClip", 1); // Enable alpha clipping
eyelashMaterial.SetFloat("_Cutoff", 0.5f); // Transparency threshold
eyelashMaterial.SetFloat("_Cull", 0); // Two-sided rendering
eyelashMaterial.SetColor("_BaseColor", new Color(0.3f, 0.2f, 0.15f, 1f)); // Dark brown, not black
eyelashMaterial.SetFloat("_Smoothness", 0.1f); // Not shiny
```

**Hair Material Settings:**
To reduce the blocky/chunky appearance of low-poly hair:
- Set smoothness to 0.3 (less shiny makes geometry less obvious)
- Ensure normal map is assigned (adds surface detail)
- Two-sided rendering may help depending on the model

See `Assets/Scripts/Editor/ThirdPersonSetup.cs` for the complete implementation of automated Mixamo character setup.

## Importing Mixamo Animations

### Workflow for Character and Animation Files

When working with Mixamo, follow this specific download and import workflow:

**1. Download Character with First Animation:**
- Go to Mixamo.com and select your character
- Choose your first animation (e.g., Idle)
- Download settings:
  - Format: **FBX for Unity (.fbx)** or **DAE**
  - Skin: **With Skin**
- This creates your main character file (e.g., `leonard.dae`)

**2. Download Additional Animations:**
- Select the same character on Mixamo
- Choose additional animations (Walk, Run, Jump, etc.)
- Download settings:
  - Format: **FBX for Unity (.fbx)** or **DAE**
  - Skin: **Without Skin** (animation only)
- Save in a subdirectory (e.g., `Assets/Characters/leonard/Idle/`)

### Import Configuration

**Character Model (With Skin):**
```csharp
// In ModelImporter for character file
modelImporter.animationType = ModelImporterAnimationType.Human;
modelImporter.avatarSetup = ModelImporterAvatarSetup.CreateFromThisModel;
modelImporter.globalScale = 0.01f; // For DAE files (100x too large)
```

**Animation Files (Without Skin):**
```csharp
// In ModelImporter for animation files
idleImporter.animationType = ModelImporterAnimationType.Human;
idleImporter.avatarSetup = ModelImporterAvatarSetup.CopyFromOther;
idleImporter.sourceAvatar = characterAvatar; // Use character's avatar
idleImporter.globalScale = 0.01f; // Match character scale for DAE
idleImporter.materialImportMode = ModelImporterMaterialImportMode.None; // Don't import materials
```

### Critical Animation Clip Settings

To prevent character from sinking into ground or appearing in wrong pose:

```csharp
ModelImporterClipAnimation clip = idleImporter.defaultClipAnimations[0];

// Loop the animation
clip.loopTime = true;

// Lock root motion (prevent animation from controlling character)
clip.lockRootRotation = true;
clip.lockRootHeightY = true;
clip.lockRootPositionXZ = false;  // CRITICAL: false for scripted movement!

// Don't use animation's baked position data
clip.keepOriginalPositionY = false;
clip.keepOriginalPositionXZ = false;

// CRITICAL: Use feet as vertical position reference (not center of mass)
// This prevents character from sinking into ground
clip.heightFromFeet = true;
```

**Why `lockRootPositionXZ = false` is critical:**
- When `true`: Locks the root position, preventing Unity from baking the animation's XZ movement into the pose
- When `false`: Allows Unity to **bake the XZ movement into the pose**, which is what you want for scripted movement
- For scripted movement (using CharacterController), you want the animation's forward/side movement baked into the character's bone poses, NOT moving the root transform
- **Symptom if set to `true`:** Character drifts away from its actual position during movement animations (like walking), then reappears at the correct position - creates a "teleporting loop" effect

**In Unity Inspector, verify:**
- Select the animation file (e.g., Walking.dae)
- Click on the "Animations" tab
- Expand the animation clip (e.g., "Take 001")
- Scroll to **"Root Transform Position (XZ)"**
- **"Bake Into Pose"** should be **checked** (green indicator)
- If it shows a red indicator, the position is not being baked and will cause drift

**Why `heightFromFeet = true` is critical:**
- Mixamo animations default to "Based Upon: Center of Mass" for Root Transform Position (Y)
- This causes the character to sink into the ground at hip level
- Setting `heightFromFeet = true` changes it to "Based Upon: Feet"
- The character now stands properly with feet on the ground

### Animator Controller Setup

**Disable Apply Root Motion:**
```csharp
animator.applyRootMotion = false; // Set AFTER assigning controller
```

Root motion should be disabled when:
- You're using scripted character movement (CharacterController, Rigidbody)
- The animation shouldn't move the character's position/rotation
- You only want the visual animation, not the root transform movement

**Common Issues:**
- If "Apply Root Motion" is enabled with scripted movement, the character will sink or have positioning conflicts
- The setting may reset when assigning a new controller, so set it AFTER controller assignment

### Avatar Retargeting

**CRITICAL:** All animation files for the same character must use the SAME avatar:
- Character file: **Create From This Model**
- Animation files: **Copy From Other Avatar** (reference the character's avatar)

**Problem if using different avatars:**
- Even for the same Mixamo character, different avatars can cause pose mismatches
- Symptoms: bent legs, twisted joints, character in wrong pose
- Solution: Always copy the avatar from the original character model

### Finding Animation Clips

Animation clips are nested inside model files:
```csharp
// Load all assets from the animation file
UnityEngine.Object[] allAssets = AssetDatabase.LoadAllAssetsAtPath(animationPath);
AnimationClip clip = allAssets.OfType<AnimationClip>().FirstOrDefault();
```

Mixamo animations are typically named "Take 001" by default, not by the animation name.

### Multiple Animations and State Machines

When setting up multiple animations (Idle, Walk, Run, Jump, etc.):

**Animator Controller Setup:**
1. Create an Animator Controller asset
2. Add parameters for animation control (e.g., "Speed" as Float)
3. Create animation states for each animation clip
4. Set up transitions between states with conditions

**Example: Idle ↔ Walk Transition:**
```csharp
// Add Speed parameter
controller.AddParameter("Speed", AnimatorControllerParameterType.Float);

// Create states
var idleState = stateMachine.AddState("Idle");
idleState.motion = idleClip;

var walkState = stateMachine.AddState("Walk");
walkState.motion = walkClip;

// Idle → Walk transition (when moving)
var idleToWalk = idleState.AddTransition(walkState);
idleToWalk.AddCondition(AnimatorConditionMode.Greater, 0.1f, "Speed");
idleToWalk.hasExitTime = false;
idleToWalk.duration = 0.25f;

// Walk → Idle transition (when stopped)
var walkToIdle = walkState.AddTransition(idleState);
walkToIdle.AddCondition(AnimatorConditionMode.Less, 0.1f, "Speed");
walkToIdle.hasExitTime = false;
walkToIdle.duration = 0.25f;
```

**In Movement Script:**
```csharp
// Get animator reference
animator = GetComponentInChildren<Animator>();

// Update in movement code
float normalizedSpeed = currentSpeed / walkSpeed;
animator.SetFloat("Speed", normalizedSpeed);
```

### Complete Automated Setup

The `ThirdPersonSetup.cs` script automates all of this:
1. Configures character model with correct scale and avatar
2. Finds and configures animation files in subdirectories
3. Sets up avatar copying for animation retargeting
4. Configures animation clips with proper root transform settings (including `lockRootPositionXZ = false`)
5. Creates Animator Controller with parameters and animation states
6. Sets up state transitions based on movement parameters
7. Assigns controller and disables Apply Root Motion

See `Assets/Scripts/Editor/ThirdPersonSetup.cs` → `ConfigureAnimation()`, `ConfigureAnimationFile()`, and `SetupAnimatorController()` for the complete implementation.

## Editor Scripts

Scripts in `Editor/` folders run in the Unity Editor, not in builds:
- Used for custom Inspector windows, menu items, asset processors
- Cannot reference `UnityEngine.MonoBehaviour` in built players
- Use `UnityEditor` namespace

## Testing

Unity Test Framework supports:
- **Edit Mode tests**: Test editor scripts and logic without Play Mode
- **Play Mode tests**: Test runtime behavior in simulated Play Mode
- Run tests via Unity Editor: Window → General → Test Runner

### Running Tests
Tests must be run through Unity Editor's Test Runner window, not command line in a standard workflow.

## Platform Considerations

- Unity builds to multiple platforms (Windows, Mac, Linux, iOS, Android, WebGL, consoles)
- Platform-specific code uses `#if UNITY_STANDALONE` preprocessor directives
- Input System automatically handles platform-specific input devices

## Common Patterns

### Singletons
```csharp
public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

### Coroutines
Unity's way of handling async behavior over time:
```csharp
IEnumerator DelayedAction()
{
    yield return new WaitForSeconds(2f);
    // Execute after 2 seconds
}

// Start with:
StartCoroutine(DelayedAction());
```

### ScriptableObjects
Data containers that persist as assets:
```csharp
[CreateAssetMenu(menuName = "Game/Data")]
public class GameData : ScriptableObject
{
    public int maxHealth;
    public float speed;
}
```
