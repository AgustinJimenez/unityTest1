# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Unity 6000.3.2f1 (Unity 6) project configured with Universal Render Pipeline (URP) and the new Input System.

## Key Packages

- **Universal Render Pipeline (URP)**: 17.3.0 - Modern rendering pipeline
- **Input System**: 1.17.0 - New input system (not the legacy Input Manager)
- **AI Navigation**: 2.0.9 - NavMesh components
- **Visual Scripting**: 1.9.9 - Node-based scripting
- **Timeline**: 1.8.9 - Cinematic and animation sequencing
- **Test Framework**: 1.6.0 - Unity's testing framework

## Project Structure

```
Assets/
├── Scenes/              # Unity scenes
├── Scripts/             # Game scripts and components
│   └── Editor/          # Editor tools and automation
├── Settings/            # Project-specific settings
├── TutorialInfo/        # Template tutorial assets
└── InputSystem_Actions.inputactions  # Input Action asset
```

## Development Workflow with Claude Code

### Iterative Development Cycle

When working with Claude Code on this Unity project, follow this workflow:

1. **Claude Code Updates Scripts**: Claude modifies C# files in `Assets/Scripts/`
2. **Unity Auto-Compiles**: Unity Editor detects file changes and recompiles automatically
   - Watch the bottom-right corner for the spinning icon (compiling)
   - Wait until it says "Ready" or the spinner disappears
   - **There is no command to force compilation** - Unity handles this internally
3. **User Tests in Unity Editor**: Press Play to test changes
4. **Provide Feedback**: Report what works/doesn't work
5. **Iterate**: Repeat steps 1-4 until feature is complete

### Automated Setup Tools

This project includes Editor tools for quick setup:
- **Tools → Third Person → Auto Setup Scene**: Creates player, camera, and ground automatically
- **Tools → Third Person → Remove Setup**: Cleans up the scene setup
- These tools handle GameObject creation, component configuration, and linking

### Real-Time Value Tuning

For faster iteration when adjusting parameters:
1. Enter **Play Mode** in Unity Editor
2. Select the GameObject (e.g., Main Camera, Player)
3. Modify serialized fields directly in the Inspector
4. See changes **immediately** without stopping/restarting
5. Once satisfied, note the values and have Claude update the script defaults

**Note**: Changes made during Play Mode are lost when exiting Play Mode, so always have Claude update the script with final values.

### Script Compilation Limitations

- Unity Editor must be running for compilation to occur
- Compilation happens automatically when Unity detects file changes
- No external command-line tool can trigger Unity's internal compiler
- Asset refreshing (Assets → Refresh or Ctrl+R) can help if changes aren't detected

## Unity Editor Workflow

Unity projects are primarily developed through the Unity Editor, not through command-line builds. The `.csproj` and `.sln` files are auto-generated by Unity and should not be manually edited.

### Opening the Project
1. Open Unity Hub
2. Add this project folder
3. Open with Unity Editor 6000.3.2f1 or compatible version

### Creating Scripts
New C# scripts should be created through:
- Unity Editor: Right-click in Project window → Create → C# Script
- This ensures proper MonoBehaviour template and meta files

### Testing in Play Mode
- Use Unity Editor's Play button to test
- Scripts execute in the context of scenes and GameObjects

## Input System

This project uses the **new Input System**, not the legacy Input Manager.

- Input actions are defined in `Assets/InputSystem_Actions.inputactions`
- Access input through Input Action references, not `Input.GetKey()`
- Player Input component should be used on GameObjects

## Architecture Notes

### MonoBehaviour Lifecycle
Unity scripts inherit from MonoBehaviour and use Unity's lifecycle methods:
- `Awake()` - Called when script instance is loaded
- `Start()` - Called before first frame update
- `Update()` - Called every frame
- `FixedUpdate()` - Called at fixed time intervals (physics)
- `OnDestroy()` - Called when object is destroyed

### Scene-Based Architecture
- Logic is organized into scenes (`.unity` files)
- Scripts attach to GameObjects in the Hierarchy
- Communication between objects via references, events, or singleton patterns

### SerializeField Pattern
Unity serializes public fields and `[SerializeField]` private fields:
```csharp
[SerializeField] private float speed = 5f;  // Visible in Inspector
private float health = 100f;                 // Not visible in Inspector
```

## URP Rendering

This project uses Universal Render Pipeline:
- URP Asset configures rendering quality and features
- Custom shaders should use Shader Graph or URP shader templates
- Post-processing effects use Volume components
- URP-specific lighting and shadow settings apply

## Importing Mixamo Characters with Textures

### Common Issue: Dark or Missing Textures

When importing Mixamo characters (especially DAE format) into Unity URP, textures often appear dark or missing. This was resolved through the following understanding:

**Root Cause:**
- Mixamo characters use **multiple texture sets** (e.g., Ch31_1001 for body, Ch31_1002 for hair)
- All materials share the same prefix (e.g., "Ch31"), so naive texture searching finds ALL textures for ALL materials
- If you assign textures without filtering, the LAST texture overwrites all previous ones
- This causes wrong textures to be applied (e.g., dark hair texture on body material)

**Texture Naming Convention (Mixamo):**
- `Ch31_1001_Diffuse.png` - Body/skin texture (usually brighter)
- `Ch31_1002_Diffuse.png` - Hair texture (usually darker)
- `Ch31_1001_Normal.png` - Body normal map
- `Ch31_1001_Specular.png` - Body specular map
- Pattern: `{CharacterID}_{TextureSet}_{TextureType}.png`

**Solution:**
Match textures to materials intelligently based on material names:
```csharp
// Determine which texture set to use based on material name
string preferredTextureNumber = "";
if (materialName.ToLower().Contains("hair"))
{
    preferredTextureNumber = "1002"; // Hair textures
}
else if (materialName.ToLower().Contains("body"))
{
    preferredTextureNumber = "1001"; // Body textures
}

// Only assign textures that match the preferred set
bool isPreferredTexture = string.IsNullOrEmpty(preferredTextureNumber)
    || textureName.Contains(preferredTextureNumber);
```

**Key Points:**
1. **DAE files are 100x too large** - Apply `transform.localScale = Vector3.one * 0.01f` for DAE imports
2. **Materials use Specular workflow** - Set `material.SetFloat("_WorkflowMode", 1f)` for URP/Lit shader
3. **Enable Specular keyword** - Call `material.EnableKeyword("_SPECULAR_SETUP")` to activate Specular rendering
4. **One diffuse per material** - Only assign the FIRST matching diffuse texture to prevent overwriting
5. **Normal maps must be configured** - Set texture import type to `TextureImporterType.NormalMap`

**Lighting Requirements:**
- Set ambient lighting: `RenderSettings.ambientMode = AmbientMode.Flat` with bright color
- Increase directional light intensity to 2-3 for better visibility
- Mixamo characters can appear dark without proper ambient lighting

**Eyelash Rendering Fix:**
Mixamo eyelashes often appear as thick black bars in Unity instead of subtle, natural lashes. This is because:
- Eyelashes use the hair material by default (too dark and opaque)
- They need alpha clipping and two-sided rendering to look natural

Solution - create a dedicated eyelash material:
```csharp
Material eyelashMaterial = new Material(Shader.Find("Universal Render Pipeline/Lit"));
eyelashMaterial.SetFloat("_AlphaClip", 1); // Enable alpha clipping
eyelashMaterial.SetFloat("_Cutoff", 0.5f); // Transparency threshold
eyelashMaterial.SetFloat("_Cull", 0); // Two-sided rendering
eyelashMaterial.SetColor("_BaseColor", new Color(0.3f, 0.2f, 0.15f, 1f)); // Dark brown, not black
eyelashMaterial.SetFloat("_Smoothness", 0.1f); // Not shiny
```

**Hair Material Settings:**
To reduce the blocky/chunky appearance of low-poly hair:
- Set smoothness to 0.3 (less shiny makes geometry less obvious)
- Ensure normal map is assigned (adds surface detail)
- Two-sided rendering may help depending on the model

See `Assets/Scripts/Editor/ThirdPersonSetup.cs` for the complete implementation of automated Mixamo character setup.

## Editor Scripts

Scripts in `Editor/` folders run in the Unity Editor, not in builds:
- Used for custom Inspector windows, menu items, asset processors
- Cannot reference `UnityEngine.MonoBehaviour` in built players
- Use `UnityEditor` namespace

## Testing

Unity Test Framework supports:
- **Edit Mode tests**: Test editor scripts and logic without Play Mode
- **Play Mode tests**: Test runtime behavior in simulated Play Mode
- Run tests via Unity Editor: Window → General → Test Runner

### Running Tests
Tests must be run through Unity Editor's Test Runner window, not command line in a standard workflow.

## Platform Considerations

- Unity builds to multiple platforms (Windows, Mac, Linux, iOS, Android, WebGL, consoles)
- Platform-specific code uses `#if UNITY_STANDALONE` preprocessor directives
- Input System automatically handles platform-specific input devices

## Common Patterns

### Singletons
```csharp
public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}
```

### Coroutines
Unity's way of handling async behavior over time:
```csharp
IEnumerator DelayedAction()
{
    yield return new WaitForSeconds(2f);
    // Execute after 2 seconds
}

// Start with:
StartCoroutine(DelayedAction());
```

### ScriptableObjects
Data containers that persist as assets:
```csharp
[CreateAssetMenu(menuName = "Game/Data")]
public class GameData : ScriptableObject
{
    public int maxHealth;
    public float speed;
}
```
